#!/usr/bin/env python

import sys, getopt, re, os

"""
=====================================================================================================
=
= This is the parsing component of the SELinux Policy originator.
=
= Purpose:
= The parser takes the m4 marco expansion of SELinux policies and parses it into a suitable and
= useful manner for the workflow component of the policy originator to database.
= 
= Author: Devan Franchini
=
= Notes: For any questions, errors to report, or general calamity regarding the SELinux policy 
= originator, please contact me at my email: oot153@gmail.com*
=
= *I am not responsible for anything you do of your own accord. If for some rhyme or reason you 
= start a nuclear holocaust using this parser, or your computer isn't able to create toast anymore
= and you blame me I will point and laugh. That being said, any other problems that are not
= self-inflicted will be addressed and acknowledged. I will try and aid you as soon as possible.
=
= Look at me still talking while there's science to do....
=
=====================================================================================================
"""

def usage():
    print("Proper usage:\npolicy-parser -i(--input) [file to parse] -o(--output) [parsed file location]")
    sys.exit(0)

letter = 'hi:o:'
keyword = ['input=','output=','help']

opts, extraparams = getopt.getopt(sys.argv[1:], letter, keyword)

outputCheck = False                                                  # Boolean check to see if output location has been set.
defaultLocation= os.path.join(os.environ["PWD"],'parsedOutput.txt') # Default location, in case of no declared output location.

#Set up arguement flags for execution of this script.
for o, p in opts:
    if o in ['-i', '--input']:
        inputFile=p
    elif o in ['-o', '--output']:
        outputFile=p
        outputCheck=True
    elif o in ['-h', '--help']:
        usage()

# Sanity check to make sure the parsed information is getting written to some location.
if outputCheck == False:
    outputFile=defaultLocation
    print ("\nOutput location not specified, defaulting to: " + outputFile)

try:
    f=open(inputFile, 'r')            # This creates the function for opening the file, and assigns it to f.
    parsedOut = open(outputFile, 'w') # This assigns a new file to parsedOut
    fileLines=f.readlines()           # Reads in the file to be edited and assigns it to c.

    sourceRecordCount = 0
    for line in fileLines:
        # Parse only if we have a .te line
        if re.search('\.te:', line):

            line = re.sub('^.*\- ', '', line)    # Greedily remove everything before -
            line = re.sub('dnl.*$', '', line)    # Remove macro comments
            if re.search('^\w*$', line):         # Skip lines that are all white space
                continue

            sourceRecordCount += 1
            parsedOut.write("## source record ")
            parsedOut.write(str(sourceRecordCount))
            parsedOut.write("# " + line)
            print("DEBUG: " + str(sourceRecordCount) + ": " + line),

    f.close()

except IOError as err:
    print("\nI/O error: {0}".format(err),"\n")
    usage()

except NameError as err:
    print("\nName error: {0}".format(err),"\n")
    usage()
