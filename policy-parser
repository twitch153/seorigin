#!/usr/bin/env python

import sys, getopt, re, os

"""
=====================================================================================================
=
=   This file is part of seorigin
=  Copyright (C) 2012  Devan Franchini, Anthony G. Basile, Sven Vermeulen
=
=  seorigin is free software: you can redistribute it and/or modify
=  it under the terms of the GNU General Public License as published by
=  the Free Software Foundation, either version 3 of the License, or
=
=  seorigin is distributed in the hope that it will be useful,
=  but WITHOUT ANY WARRANTY; without even the implied warranty of
=  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
=  GNU General Public License for more details.
=
=  You should have received a copy of the GNU General Public License
=  along with seorigin.  If not, see <http://www.gnu.org/licenses/>.
=
=  ----
= policy-parser.py is the parsing component of seorigin, the SELinux Policy originator.
=
= Purpose:
= The parser takes the m4 marco expansion of SELinux policies and parses it into a suitable and
= useful manner for the workflow component of the policy originator to database.
= 
= See README for more information.
=
=====================================================================================================

"""

def usage():
    print("Proper usage:\npolicy-parser -i(--input) [file to parse] -o(--output) [parsed file location]")
    sys.exit(0)

letter = 'i:o:h'
keyword = ['input=','output=','help']

opts, extraparams = getopt.getopt(sys.argv[1:], letter, keyword)

outputCheck = False                                                  # Boolean check to see if output location has been set.
defaultLocation= os.path.join(os.environ["PWD"],'parsedOutput.txt') # Default location, in case of no declared output location.

#Set up arguement flags for execution of this script.
for o, p in opts:
    if o in ['-i', '--input']:
        inputFile=p
    elif o in ['-o', '--output']:
        outputFile=p
        outputCheck=True
    elif o in ['-h', '--help']:
        usage()

# Sanity check to make sure the parsed information is getting written to some location.
if outputCheck == False:
    outputFile=defaultLocation
    print ("\nOutput location not specified, defaulting to: " + outputFile)

try:
    f=open(inputFile, 'r')            # This creates the function for opening the file, and assigns it to f.
    parsedOut = open(outputFile, 'w') # This assigns a new file to parsedOut
    fileLines=f.readlines()           # Reads in the file to be edited and assigns it to c.

    sourceCount = 0
    definitionCount = 0
    for line in fileLines:
        # Parse only if we have a .te line
        if re.search('\.te:', line):
            line = re.sub('dnl.*$', '', line)    # Remove macro comments
            line = re.sub('\m4trace:','', line)
            line = re.sub(': \-\d+\-', '', line)
            # Take line and break the parts after the file location into the source expression
            sourceExpression = re.sub('^.*\d+ ', '',line)
            sourceExpression = re.sub('\s', '', sourceExpression) # Remove all white space in the line
            sourceExpression = re.sub('policy.*$', '', sourceExpression)
            sourceExpression = re.sub('[ififn]def.*$', '', sourceExpression)
            sourceExpression = re.sub('ifelse.*$', '', sourceExpression)
            sourceExpression = re.sub('pushdef.*$', '', sourceExpression)
            sourceExpression = re.sub('popdef.*$', '', sourceExpression)
            sourceExpression = re.sub('gen_require.*$', '', sourceExpression) 
            sourceExpression = re.sub('incr\(\d+\)->\d+', '', sourceExpression)
            
            sourceExpression = re.sub('->', '', sourceExpression)
            sourceExpression = re.sub('_perms.*$', '', sourceExpression) 
            sourceExpression = re.sub('^.*regexp.*$', '', sourceExpression)
            # Greedily remove everything after line number and turn it into our source location
            sourceLocation = re.sub('\s+.*$', '', line)  
            if re.search('^\w*$', sourceExpression):       # Skip lines that are all white space
                continue
            elif re.search('^\w*$', line):
                continue
            elif re.search('^\w*$', sourceLocation):
                continue

            sourceCount += 1
            parsedOut.write("## source record ")
            parsedOut.write(str(sourceCount) + "\n")
            parsedOut.write("# " + sourceLocation + "\n")
            parsedOut.write(sourceExpression + "\n\n")
        # Parse out only if we have an "all_interfaces.conf:" line
        elif re.search('\m4trace:tmp/all_interfaces.conf:*.', line):

            line = re.sub('^.*\- ', '', line)
            line = re.sub('dnl.*$', '', line)
            line = re.sub('divert\(-1\)','', line)
            line = re.sub('define\(','', line)
            definitionCall = re.sub(',', '', line)
            if re.search('^\w*$', line):
                continue

            definitionCount += 1
            parsedOut.write("## definition record ")
            parsedOut.write(str(definitionCount) + "\n")
            parsedOut.write("# " + definitionCall)
            parsedOut.write(line + "\n")
            print("Definition DEBUG: " + str(definitionCount) + ": " + definitionCall)

    f.close()

except IOError as err:
    print("\nI/O error: {0}".format(err),"\n")
    usage()

except NameError as err:
    print("\nName error: {0}".format(err),"\n")
    usage()
