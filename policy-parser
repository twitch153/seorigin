#!/usr/bin/env python

import sys, getopt, re, os

"""
=====================================================================================================
=
=   This file is part of seorigin
=  Copyright (C) 2012  Devan Franchini, Anthony G. Basile, Sven Vermeulen
=
=  seorigin is free software: you can redistribute it and/or modify
=  it under the terms of the GNU General Public License as published by
=  the Free Software Foundation, either version 3 of the License, or
=
=  seorigin is distributed in the hope that it will be useful,
=  but WITHOUT ANY WARRANTY; without even the implied warranty of
=  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
=  GNU General Public License for more details.
=
=  You should have received a copy of the GNU General Public License
=  along with seorigin.  If not, see <http://www.gnu.org/licenses/>.
=
=  ----
= policy-parser.py is the parsing component of seorigin, the SELinux Policy originator.
=
= Purpose:
= The parser takes the m4 marco expansion of SELinux policies and parses it into a suitable and
= useful manner for the workflow component of the policy originator to database.
= 
= See README for more information.
=
=====================================================================================================

"""

def usage():
    print("Proper usage:\npolicy-parser -i(--input) [file to parse] -o(--output) [parsed file location]")
    sys.exit(0)

def parse_cmd_args():
    shortOpts = 'i:o:h'
    longOpts = ['input=','output=','help']

    opts, extraparams = getopt.getopt(sys.argv[1:], shortOpts, longOpts)
    
    inputCheck = True    # Boolean check to see if input location has been set.
    outputCheck = True   # Boolean check to see if output location has been set.
    defInFile = 'refpolicy/debug.log' # Default input location.
    defOutFile = os.path.join(os.environ["PWD"],'parsedOutput.txt') # Default output location.

    #Set up arguement flags for script execution.
    for o, p in opts:
        if o in ['-i', '--input']:
            inputFile=p
            inputCheck = False
        elif o in ['-o', '--output']:
            outputFile=p
            outputCheck= False
        elif o in ['-h', '--help']:
            usage()

# Sanity check to make sure the parsed information is getting written to some location.
    if outputCheck:
        outputFile=defOutFile
        print ("\nOutput location not specified, defaulting to: " + defOutFile)
    if inputCheck:
        inputFile=defInFile
        print ("\nInput location not specified, defaulting to: " + defInFile)
    return( inputFile, outputFile )

def readInput( inputFile ):
    try:
        f=open(inputFile, 'r') # This creates the function for opening the file, and assigns it to f.
    except Exception as err:
        print("\n Error: {0}".format(err),"\n")    
        usage()
        
    fileLines = f.readlines()        
    f.close()

    return fileLines

def parseFile( lines ):
    output = ''
    sourceCount = 0
    definitionCount = 0
    for line in lines:
        # Parse only if we have a .te line
        if re.search('\.te:', line):
            line = re.sub('dnl.*$', '', line)    # Remove macro comments
            line = re.sub('\m4trace:','', line)
            line = re.sub(': \-\d+\-', '', line)
            # Take line and break the parts after the file location into the source expression
            sourceExpression = re.sub('^.*\d+ ', '',line)
            sourceExpression = re.sub('\s', '', sourceExpression) # Remove all white space in the line
            sourceExpression = re.sub('policy.*$', '', sourceExpression)
            sourceExpression = re.sub('[ififn]def.*$', '', sourceExpression)
            sourceExpression = re.sub('ifelse.*$', '', sourceExpression)
            sourceExpression = re.sub('pushdef.*$', '', sourceExpression)
            sourceExpression = re.sub('popdef.*$', '', sourceExpression)
            sourceExpression = re.sub('gen_require.*$', '', sourceExpression) 
            sourceExpression = re.sub('incr\(\d+\)->\d+', '', sourceExpression) 
            sourceExpression = re.sub('->', '', sourceExpression)
            sourceExpression = re.sub('_perms.*$', '', sourceExpression) 
            sourceExpression = re.sub('^.*regexp.*$', '', sourceExpression)
            # Greedily remove everything after line number and turn it into our source location
            sourceLocation = re.sub('\s+.*$', '', line)  
            if re.search('^\w*$', sourceExpression):       # Skip lines that are all white space
                continue
            elif re.search('^\w*$', line):
                continue
            elif re.search('^\w*$', sourceLocation):
                continue

            sourceCount += 1
            output += "## source record "
            output += str(sourceCount) + "\n"
            output += "# " + sourceLocation + "\n"
            output += sourceExpression + "\n\n"
        # Parse out only if we have an "all_interfaces.conf:" line
        elif re.search('\m4trace:tmp/all_interfaces.conf:*.', line):

            line = re.sub('^.*\- ', '', line)
            line = re.sub('dnl.*$', '', line)
            line = re.sub('divert\(-1\)','', line)
            line = re.sub('define\(','', line)
            definitionCall = re.sub(',', '', line)
            if re.search('^\w*$', line):
                continue

            definitionCount += 1
            output += "## definition record "
            output += str(definitionCount) + "\n"
            output += "# " + definitionCall
            output += line + "\n"
            print("Definition DEBUG: " + str(definitionCount) + ": " + definitionCall)

    return output

def writeOut( outputFile, output ):
    try:
        parsedOut = open(outputFile, 'w') # This assigns a new file to parsedOut
    except Exception as err:
        print("Error: {0}".format(err),"\n")
        usage()

    parsedOut.write(output)
    parsedOut.close()

def main():
    (inputFile, outputFile) = parse_cmd_args()
    lines = readInput( inputFile )
    output = parseFile( lines )
    writeOut( outputFile, output )
if __name__ == "__main__":
    main()
